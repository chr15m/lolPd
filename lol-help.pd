#N canvas 189 69 491 708 10;
#X msg 173 117 12;
#X text 19 341 In addition to standard Pd objects \, you can also insert
the following functions into a pipeline:;
#X msg 24 118 bang;
#X obj 24 226 print random;
#X obj 173 200 print counter;
#X text 17 8 lol is a tiny domain-specific language for doing simple
programmatic tasks and list-comprehensions in Pure Data. It exists
to try and prevent RSI. Internally \, lol creates vertical stacks of
Pd objects connected by a single pipeline and data runs as usual from
top to bottom., f 74;
#X msg 317 115 4;
#X text 21 87 generate 16 random \; floats between 0 & 1;
#X text 170 86 output 10 integers \; starting at 12;
#X text 314 84 output N midi values \; defaults to 16 on load.;
#X obj 317 240 print midictl;
#X text 19 647 NOTES \; the lol object currently has a limitation of
128 atoms \; the last atom should always be a semicolon and never a
0 \; use the ^ modifier to make "local" \$0-prepended send/receive
variables \;, f 74;
#X obj 24 139 lol loadbng \; range 16 \; tee inc \; bng \; random 128
\; / 128 \;;
#X obj 24 252 r inc;
#X obj 24 274 print inc;
#X text 61 253 (global);
#X obj 173 139 lol tee ^ val \; range 10 \; concat ^ val \; expr $f1
+ $f2 \;;
#X text 172 225 "val" above is \; local to the lol \; instance \;;
#X obj 317 138 lol tee ^ count \; loadbng \; concat ^ count \; default
16 \; range \; bng \; random 128 \;;
#X text 105 311 <- more examples;
#X obj 21 311 lol-examples;
#X text 19 376 range = output a range of numbers using [until] and
an internal counter \; tee X = send value to X and then pass it through
(use ^ X to make local) \; teef X = pass the value through and then
send to X \; loadbng = loadbang with an inlet that you can bang again
\; concat X = receive X and concatenate onto incoming values \; each
= drip the incoming list out one atom at a time \; item X = incoming
value specifies the Nth item to look up from values X \; pr X = print
incoming values with print-prefix of X & pass through \; pop X = pop
the first value off the list and send the rest to X \; merge X = receive
from X and merge with the pipeline (fan in) \; gather X = collect incoming
values into a list until we receive from X \; gathern N = collect incoming
values into lists of length N \; slice N [M] = pass through M values
starting from the Nth of the list \; lookup = lookup values from a
list by index \; into-message = prepend a "set" so the list can go
into an empty message \; into-table X = send the incoming list to a
table called X & pass through \; . X = only output whater was last
received when X also receives \; # = start of a comment (null object
that passes everything through) \; map = drip the values of a list
through the subpatch specified by args \; reduce = like map but folds
values into the second inlet and outputs once \;, f 74;
#X connect 0 0 16 0;
#X connect 2 0 12 0;
#X connect 6 0 18 0;
#X connect 12 0 3 0;
#X connect 13 0 14 0;
#X connect 16 0 4 0;
#X connect 18 0 10 0;
